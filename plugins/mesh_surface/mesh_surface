#!/usr/bin/env python

##########################################################################
#
#  QGIS-meshing plugins.
#
#  Copyright (C) 2012-2013 Imperial College London and others.
#
#  Please see the AUTHORS file in the main source directory for a
#  full list of copyright holders.
#
#  Dr Adam S. Candy, adam.candy@imperial.ac.uk
#  Applied Modelling and Computation Group
#  Department of Earth Science and Engineering
#  Imperial College London
#
#  This library is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation,
#  version 2.1 of the License.
#
#  This library is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#  USA
#
##########################################################################

'''
USAGE
call using: python <filepath to mesh_terminal>/mesh_terminal [commands] <DomainFile> <IdFile> <MeshmetricFile>
'''

import sys
from scripts import define_id, export_geo
from scripts.MeshOperations import MeshOp
from scripts.PosFileConverter import *
import os
from scripts.flat_mesh_to_spherical import flat_mesh_spherical
import scripts.bathy_to_field as btyf
import subprocess

class _baseCommands( object ):
	def _usage( self ):
		print '''
		USAGE
		call using: python <filepath to mesh_terminal>/mesh_terminal [COMMANDS] <DomainFile> <IdFile> <Meshmetric>

		enables mesh_surface functionality in terminal. Including both geofile,
		shapefile and meshfile manipulation with the option of mesh metrics based
		on netcdf files.

		COMMANDS
		-h	--help		:Displays this message
			--id		:sets the shapefile used for boundary ids
			--defid		:sets the default id
		-m	--metric	:sets the netcdf used as the mesh metric
		-t	--threshold	:filters the domain for island area in km^2
		-g	--geo		:uses a geofile as a domain instead of a shapefile
			--mesh		:calls gmsh for meshing
		-c	--coord		:sets the coordinate space for meshing use:
						F for flat
						L for lonlat projection to sphere
						S for stereographic
						defaults to flat
		-s	--show		:sets the gmsh call for showing mesh/geo
		-l	--line		:sets the line type used when writing the geofile:
						LN for lines with compound lines disabled
						LY for lines with compound lines enabled
						BN for BSplines with compound lines disabled
						BY for BSplines with compound lines enabled
			--mval		:sets a math eval field
		-e			:Shows all errors found after command.
		'''

class _mainObject ( define_id.DefineDomain, _baseCommands, MeshOp, export_geo.geometry_writer ):

	domainShapefileLayerFileName = None
	threshold = None
	idFilePath = None
	isIdLayer = False
	geofilepath = None
	singleNetCDFLayerFileName = None
	fieldFileName = None
	compound_line_enable = False
	gmshcall = False
	gmshShow = False
	defID = 0
	coord = 'F'
	BSpline = True
	Compound = False
	mEval = None
	errorHide = True

	commands = {
	'-h':'self._usage()',
	'--help':'self._usage()',
	'--id':'self.get_id()',
	'--defid':'self.set_defid()',
	'--metric':'self.get_metric()',
	'-m':'self.get_metric()',
	'--threshold':'self.set_threshold()',
	'-t':'self.set_threshold()',
	'--geo':'self.set_geo()',
	'-g':'self.set_geo()',
	'--mesh':'self.call_gmsh()',
	'--coord':'self.set_cspace()',
	'-c':'self.set_cspace()',
	'-s':'self.set_gmshShow()',
	'--show':'self.set_gmshShow()',
	'-l':'self.set_lineType()',
	'--line':'self.set_lineType()',
	'--mval':'self.set_mevalcall()',
	'-e':'self.error_explicit()'
	}

	lineType = {
	'LN':'self.BSpline = False; self.Compound = False',
	'LY':'self.BSpline = False; self.Compound = True',
	'BN':'self.BSpline = True; self.Compound = False',
	'BY':'self.BSpline = True; self.Compound = True',
	}

#note compound lines are not being written are bsplines?

	def __init__( self ):
		self.sarg = sys.argv[1:]
		self.read_sarg()
		if self.domainShapefileLayerFileName != None:
			self.define_bounds(self.isIdLayer)
			self.data = [self.domainData.regionIDs,self.domainData.shapes,self.boundaryIDList,self.domainData.points]
			if self.geofilepath == None:
				self.geofilepath = '%s_idBoundary.geo' % self.domainShapefileLayerFileName[:-4]
			self.GeoWriter()
			if self.mEval != None:
				self.write_meval()
			if self.fieldFileName != None:
				self.geoFileName = self.geofilepath
				self.gradeToNCFlat()
		if self.gmshcall:
			self.generate_mesh()

			meshpath = self.geofilepath[:-3] + 'msh'
			if self.coord == 'L':
				print "Projecting to Sphere..."
				meshpath = flat_mesh_spherical(meshpath,self.coord == 'S')
				print "Mesh Projected."
			if self.gmshShow: #this is not currently working
				self.generate_mesh(meshpath, __file__)

		else:
			if self.gmshShow:
				self.generate_mesh()



	#calls GMSH to perform mesh generation. Logs the GMSH output into
	#gmsh_output.log and ay errors encountered to errors.log. Both files can
	#be found in the output folder.
	def generate_mesh(self) :

		out = open(os.path.dirname(os.path.realpath(__file__)) + "/../../tests/output/gmsh_output.log", "a")
		err = open(os.path.dirname(os.path.realpath(__file__)) + "/../../tests/output/errors.log", "a")
		command = 'gmsh'
		commandfull = command + ' -v 3 -2 ' + str(self.geofilepath)
		process = subprocess.Popen(commandfull, shell=True, stdout=out, stderr=err)

		process.wait()


	def read_sarg( self ):
		carg = self.sarg.pop(0)
		if '.shp' in carg and self.domainShapefileLayerFileName == None:
			self.domainShapefileLayerFileName = carg
		elif '.nc' in carg:
			self.singleNetCDFLayerFileName = carg
			self.postviewFileName = carg[:-2]+'pos'
			converter.writePosFile(self)
		else:
			if self.errorHide:
				try:
					eval(self.commands[carg])
				except:
					#self._usage()
					print 'Warning:  Incorrect Terminal Commands. Failure at %s.' % carg
			else:
				eval(self.commands[carg])
			#else:
			#	self.idFilePath = carg
			#	self.isIdLayer = True
		if self.sarg != []:
			self.read_sarg()

	def get_metric( self ):
		self.singleNetCDFLayerFileName = self.sarg.pop(0)
		self.fieldFileName = self.singleNetCDFLayerFileName[:-2]+'fld'
                btyf.create_fld_file(self.singleNetCDFLayerFileName,self.fieldFileName)
	def get_id( self ):
		self.idFilePath = self.sarg.pop(0)
		self.isIdLayer = True
	def set_threshold( self ):
		self.threshold = self.sarg.pop(0)
	def call_gmsh( self ):
		self.gmshcall = True
		if self.sarg[0] == 'True' or self.sarg[0] == 'False':
			self.set_gmshShow()
	def set_cspace( self ):
		self.coord = self.sarg.pop(0)
	def set_geo( self ):
		self.geofilepath = self.sarg.pop(0)
	def _usage( self ):
		_baseCommands._usage(self)
	def export_geo( self ):
		export_geo.write_geo_file(self.geofilepath,self.data,self.Compound,self.BSpline)
	def define_bounds( self, isIdLayer ):
		define_id.DefineDomain.define_bounds(self,isIdLayer)
	def set_defid( self ):
		self.defID = int(self.sarg.pop(0))
	def set_gmshShow( self ):
		self.gmshShow = self.sarg.pop(0)
	def set_lineType( self ):
		exec(self.lineType[self.sarg.pop(0)])
	#def gradeToNCFlat( self ):
		#geoFile = open(str(self.geofilepath), 'a')
                #geoFile.write('\nField[1] = Structured;\n')
                #geoFile.write('Field[1].FileName = "%s";\n' % self.fieldFileName)
                #geoFile.write('Field[1].TextFormat = 1;\n')
                #geoFile.write("Background Field = 1;\n")
                #geoFile.close()
	def set_mevalcall( self ):
		self.mEval = float(self.sarg.pop(0))
	def write_meval( self ):
		geoFile = open(str(self.geofilepath), 'a')
		geoFile.write('\n//Code added by Mesh Surface to create uniform mesh.\n')
		geoFile.write("Field[1] = MathEval;\n")
		geoFile.write('Field[1].F = "%f";\n' % (self.mEval))
		geoFile.write("Background Field = 1;\n")
		geoFile.write("Mesh.CharacteristicLengthExtendFromBoundary = 0;\n")
		geoFile.close()
	def error_explicit( self ):
		self.errorHide = False


_mainObject()
